{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["/*\n * Created with @iobroker/create-adapter v2.0.1\n */\n\n// The adapter-core module gives you access to the core ioBroker functions\n// you need to create an adapter\nimport * as utils from '@iobroker/adapter-core';\n\n// Load your modules here, e.g.:\n// import * as fs from \"fs\";\nimport { libdsvdc } from 'libdsvdcts';\n//import { rgbhelper } from 'rgbhelper';\n\nlet dsDevices: Array<any> = [];\n\nclass DigitalstromVdc extends utils.Adapter {\n    vdc: any;\n    setOutputChannel: Array<any> = [];\n    allDevices: any = { backEnd: [], frondEnd: [] };\n\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: 'digitalstrom-vdc',\n        });\n        this.on('ready', this.onReady.bind(this));\n        this.on('stateChange', this.onStateChange.bind(this));\n        this.on('objectChange', this.onObjectChange.bind(this));\n        this.on('message', this.onMessage.bind(this));\n        this.on('unload', this.onUnload.bind(this));\n        this.allDevices = { backEnd: [], frondEnd: [] };\n    }\n\n    /**\n     * Is called when databases are connected and adapter received configuration.\n     */\n    private async onReady(): Promise<void> {\n        // Initialize your adapter here\n\n        this.setState('info.connection', false, true);\n\n        /*\n        For every state in the system there has to be also an object of type state\n        Here a simple template for a boolean variable named \"testVariable\"\n        Because every adapter instance uses its own unique namespace variable names can't collide with other adapters variables\n        */\n        await this.setObjectNotExistsAsync('DS-Devices.VDC.running', {\n            type: 'state',\n            common: {\n                name: 'running',\n                type: 'boolean',\n                role: 'indicator',\n                read: true,\n                write: true,\n            },\n            native: {\n                Name: 'running',\n            },\n        });\n\n        this.allDevices = await this.refreshDeviceList();\n\n        dsDevices = [];\n        this.allDevices.backEnd.forEach((d: any) => {\n            this.log.info(JSON.stringify(d.dsConfig));\n            console.log(JSON.stringify(d.dsConfig));\n            if (typeof d.watchStateID == 'object') {\n                for (const [key, value] of Object.entries(d.watchStateID)) {\n                    this.log.debug(`subscribing to ${key} / ${value}`);\n                    this.subscribeForeignStates(value as string);\n                }\n            } else if (d.watchStateID && d.watchStateID.length > 0) {\n                this.log.debug(`subscribing to ${d.watchStateID}`);\n                this.subscribeForeignStates(d.watchStateID);\n            }\n            if (d.dsConfig) {\n                this.log.debug(`Pushing ${JSON.stringify(d.dsConfig)} to devices`);\n                dsDevices.push(d.dsConfig);\n            }\n        });\n\n        // In order to get state updates, you need to subscribe to them. The following line adds a subscription for our variable we have created above.\n        // this.subscribeStates(\"testVariable\");\n        // You can also add a subscription for multiple states. The following line watches all states starting with \"lights.\"\n        // this.subscribeStates(\"lights.*\");\n        // Or, if you really must, you can also watch all states. Don't do this if you don't need to. Otherwise, this will cause a lot of unnecessary load on the system:\n        // this.subscribeStates(\"*\");\n\n        /*\n\t\t\tsetState examples\n\t\t\tyou will notice that each setState will cause the stateChange event to fire (because of above subscribeStates cmd)\n\t\t*/\n        // the variable testVariable is set to true as command (ack=false)\n        // await this.setStateAsync(\"testVariable\", true);\n\n        // same thing, but the value is flagged \"ack\"\n        // ack should be always set to true if the value is received from or acknowledged from the target system\n        // await this.setStateAsync(\"testVariable\", { val: true, ack: true });\n\n        // same thing, but the state is deleted after 30s (getState will return null afterwards)\n        // await this.setStateAsync(\"testVariable\", { val: true, ack: true, expire: 30 });\n\n        // examples for the checkPassword/checkGroup functions\n        /* let result = await this.checkPasswordAsync(\"admin\", \"iobroker\");\n        this.log.info(\"check user admin pw iobroker: \" + result);\n\n        result = await this.checkGroupAsync(\"admin\", \"admin\");\n        this.log.info(\"check group user admin group admin: \" + result);*/\n\n        this.log.debug(`dsDevices: ${JSON.stringify(this.allDevices.backEnd)}`);\n\n        const vdc = new libdsvdc({ debug: this.config.vdcDebug });\n\n        if (\n            this.config.vdcName &&\n            this.config.vdcName.length > 0 &&\n            this.config.vdcDSUID &&\n            this.config.vdcDSUID.length > 0 &&\n            this.config.vdcPort\n        ) {\n            this.log.info(`Connecting to VDC ${this.config.vdcName}`);\n            this.log.debug(`dsDevices vor dem start: ${JSON.stringify(dsDevices)}`);\n            vdc.start(\n                {\n                    vdcName: this.config.vdcName,\n                    vdcDSUID: this.config.vdcDSUID,\n                    port: this.config.vdcPort,\n                    configURL: this.config.vdcConfigURL,\n                },\n                dsDevices,\n            );\n            this.log.debug(`dsDevices nach dem start: ${JSON.stringify(dsDevices)}`);\n        }\n\n        this.vdc = vdc;\n\n        vdc.on('messageReceived', (msg: JSON) => {\n            this.log.debug(`MSG RECEIVED\" ${JSON.stringify(msg)}`);\n        });\n\n        vdc.on('messageSent', (msg: JSON) => {\n            this.log.debug(`MSG SENT\" ${JSON.stringify(msg)}`);\n        });\n\n        vdc.on('VDSM_NOTIFICATION_SET_CONTROL_VALUE', (msg: any) => {\n            this.log.debug(`received control value ${JSON.stringify(msg)}`);\n        });\n\n        vdc.on('VDSM_NOTIFICATION_SET_OUTPUT_CHANNEL_VALUE', (msg: any) => {\n            this.log.debug(`received OUTPUTCHANNELVALUE value ${JSON.stringify(msg)}`);\n\n            if (msg && msg.dSUID) {\n                msg.dSUID.forEach((id: string) => {\n                    const affectedDevice = this.allDevices.backEnd.find(\n                        (d: any) => d.dsConfig.dSUID.toLowerCase() == id.toLowerCase(),\n                    );\n                    if (affectedDevice) {\n                        // found the device -> it's an update for the device\n                        const affectedState = affectedDevice.watchStateID[msg.channelId];\n                        if (!affectedState) {\n                            return;\n                        }\n                        this.log.debug(\n                            `Received an update for state ${affectedState} in device ${affectedDevice.name} with value ${msg.value} and ${msg.applyNow}`,\n                        );\n                        this.setOutputChannel.push({\n                            name: msg.channelId,\n                            state: affectedState,\n                            value: msg.value,\n                        });\n                        const brightness = this.setOutputChannel.find((v) => v.name == 'brightness');\n                        if (brightness) {\n                            this.log.debug(`Brightness: ${brightness.value}`);\n                            if (brightness.value == 0) {\n                                const affectedStateSwitch = affectedDevice.watchStateID['switch'];\n                                this.setOutputChannel.push({\n                                    name: 'switch',\n                                    state: affectedStateSwitch,\n                                    value: false,\n                                });\n                            }\n                        } else {\n                            const affectedStateSwitch = affectedDevice.watchStateID['switch'];\n                            this.setOutputChannel.push({\n                                name: 'switch',\n                                state: affectedStateSwitch,\n                                value: true,\n                            });\n                        }\n                        this.setOutputChannel.forEach((c) => {\n                            this.setForeignStateAsync(c.state, {\n                                val: c.value,\n                                ack: false,\n                            }).then((error) => {\n                                if (error) {\n                                    /* this.log.error(\n                                        `Error performing update of the ${c.name} value (${c.value}) on ${affectedDevice.name} - ${error}`,\n                                    ); */\n                                } else {\n                                    this.log.debug(\n                                        `Successful update of ${c.name} to ${c.value} on ${affectedDevice.name}`,\n                                    );\n                                }\n                            });\n                        });\n                        this.setOutputChannel = [];\n                    }\n                });\n            }\n        });\n\n        /*        vdc.on('VDSM_NOTIFICATION_SAVE_SCENE', (msg: any) => {\n            this.log.debug(`received save scene event ${JSON.stringify(msg)}`);\n            if (msg && msg.dSUID) {\n                msg.dSUID.forEach(async (id: string) => {\n                    // this.log.debug(`searching for ${id} in ${JSON.stringify(this.config.dsDevices)}`);\n                    const affectedDevice = this.allDevices.backEnd.find(\n                        (d: any) => d.dsConfig.dSUID.toLowerCase() == id.toLowerCase(),\n                    );\n                    if (affectedDevice) {\n                        // found device -> storing current values into devicearray\n                        if (affectedDevice.deviceType == 'rgbLamp') {\n                            //  rgbLamp\n                            let key: string;\n                            let value: any;\n                            const sceneVals: any = {};\n                            // get the info on switchModeColor\n                            const SMC: any = await this.getForeignStateAsync(\n                                affectedDevice.watchStateID.switchModeColor,\n                            );\n                            for ([key, value] of Object.entries(affectedDevice.watchStateID)) {\n                                const state: any = await this.getForeignStateAsync(value);\n                                if (!affectedDevice.scenes) {\n                                    affectedDevice.scenes = [];\n                                }\n\n                                // delete scene first\n                                let dC = false;\n\n                                switch (key) {\n                                    case 'colorTemp':\n                                        dC = SMC.val ? true : false;\n                                        break;\n                                    case 'hue':\n                                        dC = SMC.val ? false : true;\n                                        break;\n                                    case 'saturation':\n                                        dC = SMC.val ? false : true;\n                                        break;\n                                }\n                                sceneVals[key] = { value: state.val, dontCare: dC }; // TODO understand and make it dynamic\n                            }\n                            affectedDevice.scenes = affectedDevice.scenes.filter((d: any) => d.sceneId != msg.scene);\n                            affectedDevice.scenes.push({ sceneId: msg.scene, values: sceneVals });\n                            this.log.debug(\n                                `Set scene ${msg.scene} on ${affectedDevice.name} ::: ${JSON.stringify(\n                                    this.allDevices.backEnd,\n                                )}`,\n                            );\n                            // make it persistent by storing it back to the device\n                            await this.setObjectAsync(\n                                `digitalstrom-vdc.0.DS-Devices.configuredDevices.${affectedDevice.id}`,\n                                {\n                                    type: 'state',\n                                    common: {\n                                        name: affectedDevice.name,\n                                        type: 'boolean',\n                                        role: 'indicator',\n                                        read: true,\n                                        write: true,\n                                    },\n                                    native: {\n                                        deviceObj: affectedDevice,\n                                    },\n                                },\n                            ).then(async (success) => {\n                                this.log.debug(`Device created ${success}`);\n                                this.allDevices = await this.refreshDeviceList();\n                            });\n                        } else if (affectedDevice.deviceType == 'lamp') {\n                            // lamp -> store nothing since only power on / off is supported\n\n                            let key: string;\n                            let value: any;\n                            const sceneVals: any = {};\n\n                            for ([key, value] of Object.entries(affectedDevice.watchStateID)) {\n                                const state: any = await this.getForeignStateAsync(value);\n                                if (!affectedDevice.scenes) {\n                                    affectedDevice.scenes = [];\n                                }\n\n                                // delete scene first\n                                const dC = false;\n\n                                sceneVals[key] = { value: state.val, dontCare: dC }; // TODO understand and make it dynamic\n                            }\n\n                            affectedDevice.scenes = affectedDevice.scenes.filter((d: any) => d.sceneId != msg.scene);\n                            affectedDevice.scenes.push({ sceneId: msg.scene, values: sceneVals });\n                            this.log.debug(\n                                `Set scene ${msg.scene} on ${affectedDevice.name} ::: ${JSON.stringify(\n                                    this.allDevices.backEnd,\n                                )}`,\n                            );\n                            // make it persistent by storing it back to the device\n                            await this.setObjectAsync(\n                                `digitalstrom-vdc.0.DS-Devices.configuredDevices.${affectedDevice.id}`,\n                                {\n                                    type: 'state',\n                                    common: {\n                                        name: affectedDevice.name,\n                                        type: 'boolean',\n                                        role: 'indicator',\n                                        read: true,\n                                        write: true,\n                                    },\n                                    native: {\n                                        deviceObj: affectedDevice,\n                                    },\n                                },\n                            ).then(async (success) => {\n                                this.log.debug(`Device created ${success}`);\n                                this.allDevices = await this.refreshDeviceList();\n                            });\n                        }\n                    }\n                });\n            }\n        });*/\n\n        vdc.on('VDSM_NOTIFICATION_SAVE_SCENE', (msg: any) => {\n            try {\n                this.log.debug(`received save scene event ${JSON.stringify(msg)}`);\n                if (msg && msg.dSUID) {\n                    msg.dSUID.forEach(async (id: string) => {\n                        // this.log.debug(`searching for ${id} in ${JSON.stringify(this.config.dsDevices)}`);\n                        const affectedDevice = this.allDevices.backEnd.find(\n                            (d: any) => d.dsConfig.dSUID.toLowerCase() == id.toLowerCase(),\n                        );\n                        let dontCare: any;\n                        affectedDevice.scenes = affectedDevice.scenes.filter((d: any) => d.sceneId != msg.scene);\n                        if (affectedDevice) {\n                            // found device -> looking if scene is already available\n                            const dScene = affectedDevice.scenes.find((s: any) => {\n                                return s.sceneId == msg.scene;\n                            });\n                            if (dScene) {\n                                // scene is already defined... loop it and get value for dc\n                                let key: any;\n                                let value: any;\n                                this.log.debug(\n                                    `looking for dontCare value inside scene ${msg.scene} -> ${JSON.stringify(dScene)}`,\n                                );\n                                for ([key, value] of Object.entries(dScene.values)) {\n                                    if (key == 'dontCare') dontCare = value; // set dontCare to current SceneValue\n                                }\n                            } else dontCare = false; //if Scene not defined until now set dontCare to false\n                            const sceneVals: any = {};\n                            let key: any;\n                            let value: any;\n                            for ([key, value] of Object.entries(affectedDevice.watchStateID)) {\n                                const state: any = await this.getForeignStateAsync(value);\n                                if (!affectedDevice.scenes) {\n                                    affectedDevice.scenes = [];\n                                }\n                                sceneVals[key] = { value: state.val, dontCare: dontCare }; // set SceneValues\n                            }\n                            affectedDevice.scenes = affectedDevice.scenes.filter((d: any) => d.sceneId != msg.scene);\n                            affectedDevice.scenes.push({ sceneId: msg.scene, values: sceneVals });\n                            this.log.debug(\n                                `Set scene ${msg.scene} on ${affectedDevice.name} ::: ${JSON.stringify(\n                                    this.allDevices.backEnd,\n                                )}`,\n                            );\n                            // make it persistent by storing it back to the device\n                            await this.setObjectAsync(\n                                `digitalstrom-vdc.0.DS-Devices.configuredDevices.${affectedDevice.id}`,\n                                {\n                                    type: 'state',\n                                    common: {\n                                        name: affectedDevice.name,\n                                        type: 'boolean',\n                                        role: 'indicator',\n                                        read: true,\n                                        write: true,\n                                    },\n                                    native: {\n                                        deviceObj: affectedDevice,\n                                    },\n                                },\n                            ).then(async (success) => {\n                                this.log.debug(`Device created ${success}`);\n                                this.allDevices = await this.refreshDeviceList();\n                            });\n                        }\n                    });\n                }\n            } catch (e) {\n                this.log.error(`received an error in SaveScene ${e.message}, stack ${e.stack}`);\n            }\n        });\n\n        vdc.on('VDSM_NOTIFICATION_CALL_SCENE', (msg: any) => {\n            try {\n                this.log.debug(`received call scene event ${JSON.stringify(msg)}`);\n                // search if the dsUID is known\n                if (msg && msg.dSUID) {\n                    msg.dSUID.forEach((id: string) => {\n                        const affectedDevice = this.allDevices.backEnd.find(\n                            (d: any) => d.dsConfig.dSUID.toLowerCase() == id.toLowerCase(),\n                        );\n                        this.log.debug(JSON.stringify(affectedDevice));\n                        const dScene = affectedDevice.scenes.find((s: any) => {\n                            return s.sceneId == msg.scene;\n                        });\n                        if (dScene) {\n                            // scene is defined... loop it and set all values\n                            let key: any;\n                            let value: any;\n                            this.log.debug(`looping the values inside scene ${msg.scene} -> ${JSON.stringify(dScene)}`);\n                            for ([key, value] of Object.entries(dScene.values)) {\n                                this.log.debug(\n                                    `performing update on state: ${key} ${JSON.stringify(\n                                        affectedDevice.watchStateID,\n                                    )} with key ${key} value ${value.value}`,\n                                );\n                                // if (key == \"switch\") value.value = true; // set power state on\n                                this.log.debug(\n                                    `setting ${value.value} of ${affectedDevice.name} to on ${affectedDevice.watchStateID[key]}`,\n                                );\n                                this.setForeignState(affectedDevice.watchStateID[key], value.value);\n                            }\n                        }\n                    });\n                }\n            } catch (e) {\n                this.log.error(`received an error in CallScene ${e.message}, stack ${e.stack}`);\n            }\n        });\n\n        vdc.on('channelStatesRequest', async (msg: any) => {\n            this.log.debug(`received request for channel status ${JSON.stringify(msg)}`);\n            // search if the dsUID is known\n            if (!(msg && msg.dSUID)) {\n                return;\n            }\n            const affectedDevice = this.allDevices.backEnd.find(\n                (d: any) => d.dsConfig.dSUID.toLowerCase() == msg.dSUID.toLowerCase(),\n            );\n            this.log.debug('FOUND DEVICE: ' + JSON.stringify(affectedDevice));\n            for (const e of msg.names) {\n                this.log.debug(`searching state on ${affectedDevice.name} for state ${e}`);\n                const affectedState = affectedDevice.watchStateID[e];\n                if (affectedState) {\n                    this.log.debug(\n                        `Received request for status for device  ${affectedDevice.name} and state ${affectedState}`,\n                    );\n                    const state: any = await this.getForeignStateAsync(affectedState);\n                    this.log.debug('msg value from state: ' + JSON.stringify(state));\n                    const subElement = {\n                        name: e,\n                        elements: [\n                            { name: 'value', value: { vDouble: state.val } },\n                            { name: 'age', value: { vDouble: 1 } },\n                        ],\n                    };\n                    vdc.sendComplexState(msg.messageId, subElement);\n                } else {\n                    this.log.error(`The device ${affectedDevice.name} has no watchState for ${e}`);\n                }\n            }\n            {\n                // send generic response\n                vdc.sendState(msg.value, msg.messageId);\n            }\n        });\n\n        /* vdc.on('binaryInputStateRequest', async (msg: any) => {\n            this.log.debug(`received request for binaryInputStateRequest ${JSON.stringify(msg)}`);\n\n            // search if the dsUID is known\n            if (msg && msg.dSUID) {\n                const affectedDevice = this.allDevices.backEnd.find(\n                    (d: any) => d.dsConfig.dSUID.toLowerCase() == msg.dSUID.toLowerCase(),\n                );\n                this.log.debug(`found device ${JSON.stringify(affectedDevice)}`);\n                if (affectedDevice && affectedDevice.deviceType == 'presenceSensor') {\n                    // const state: any = await this.getForeignStateAsync(affectedDevice.watchStateID);\n                    // const state: any = await getFState(affectedDevice.watchStateID);\n                    // this.log.debug(\"msg value from state: \" + JSON.stringify(state));\n                    // msg.value = state.val ? 1 : 0;\n                    // this.log.debug(\"msg value from state: \" + msg.value);\n                    const inputStates: Array<any> = [];\n                    affectedDevice.dsConfig.binaryInputDescriptions.forEach((i: any) => {\n                        inputStates.push({\n                            name: i.objName,\n                            age: 1,\n                            value: null,\n                        });\n                    });\n                    vdc.sendBinaryInputState(inputStates, msg.messageId);\n                } else if (affectedDevice && affectedDevice.deviceType == 'binarySensor') {\n                    const elements: Array<any> = [];\n                    for (const [key, value] of Object.entries(affectedDevice.watchStateID)) {\n                        const subState = await this.getForeignStateAsync(value as string);\n                        if (subState) {\n                            elements.push({\n                                name: key as string,\n                                elements: [\n                                    { name: 'age', value: { vDouble: 1 } },\n                                    { name: 'error', value: { vUint64: '0' } },\n                                    { name: 'value', value: { vBool: subState.val } },\n                                ],\n                            });\n                        }\n                    }\n                    vdc.sendComplexState(msg.messageId, elements);\n                } else {\n                    // send generic response\n                    vdc.sendState(msg.value, msg.messageId);\n                }\n            }\n        });*/\n\n        vdc.on('binaryInputStateRequest', async (msg: any) => {\n            this.log.info(`received request for binaryInputStateRequest ${JSON.stringify(msg)}`);\n            // search if the dsUID is known\n            if (msg && msg.dSUID) {\n                const affectedDevice = this.allDevices.backEnd.find(\n                    (d: any) => d.dsConfig.dSUID.toLowerCase() == msg.dSUID.toLowerCase(),\n                );\n                this.log.debug(`found device ${JSON.stringify(affectedDevice)}`);\n                const elements: Array<any> = [];\n                for (const [key, value] of Object.entries(affectedDevice.watchStateID)) {\n                    const subState = await this.getForeignStateAsync(value as string);\n                    if (subState) {\n                        elements.push({\n                            name: key as string,\n                            elements: [\n                                { name: 'age', value: { vDouble: 1 } },\n                                { name: 'error', value: { vUint64: '0' } },\n                                { name: 'value', value: { vBool: subState.val } },\n                            ],\n                        });\n                    }\n                    vdc.sendComplexState(msg.messageId, elements);\n                }\n            } else {\n                // send generic response\n                vdc.sendState(msg.value, msg.messageId);\n            }\n        });\n\n        vdc.on('vdcRunningState', () => {\n            this.setStateAsync('DS-Devices.VDC.running', { val: true, ack: true });\n            this.log.debug(`VDC <${this.config.vdcName}> is running on port ${this.config.vdcPort}`);\n        });\n\n        vdc.on('deviceZoneChange', (msg: any) => {\n            this.log.debug(`deviceZoneChange event received with the following information ${JSON.stringify(msg)}`);\n        });\n\n        vdc.on('updateDeviceValues', async (msg: any) => {\n            this.log.debug(`deviceUpdate received with the following information ${JSON.stringify(msg)}`);\n            const affectedDevice = this.allDevices.backEnd.find(\n                (d: any) => d.dsConfig.dSUID.toLowerCase() == msg.dSUID.toLowerCase(),\n            );\n            if (affectedDevice) {\n                affectedDevice.dsConfig = msg;\n                await this.setObjectAsync(`digitalstrom-vdc.0.DS-Devices.configuredDevices.${affectedDevice.id}`, {\n                    type: 'state',\n                    common: {\n                        name: affectedDevice.name,\n                        type: 'boolean',\n                        role: 'indicator',\n                        read: true,\n                        write: true,\n                    },\n                    native: {\n                        deviceObj: affectedDevice,\n                    },\n                }).then(async (success) => {\n                    this.log.debug(`Device created ${success}`);\n                    this.allDevices = await this.refreshDeviceList();\n                });\n            }\n        });\n        this.setState('info.connection', true, true); // TODO check right place?\n    }\n\n    /**\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\n     */\n    private onUnload(callback: () => void): void {\n        try {\n            // Here you must clear all timeouts or intervals that may still be active\n            // clearTimeout(timeout1);\n            // clearTimeout(timeout2);\n            // ...\n            // clearInterval(interval1);\n\n            // TODO end all connections and such here!!\n\n            callback();\n        } catch (e) {\n            callback();\n        }\n    }\n\n    // If you need to react to object changes, uncomment the following block and the corresponding line in the constructor.\n    // You also need to subscribe to the objects with `this.subscribeObjects`, similar to `this.subscribeStates`.\n    // /**\n    //  * Is called if a subscribed object changes\n    //  */\n    // private onObjectChange(id: string, obj: ioBroker.Object | null | undefined): void {\n    // \tif (obj) {\n    // \t\t// The object was changed\n    // \t\tthis.log.debug(`object ${id} changed: ${JSON.stringify(obj)}`);\n    // \t} else {\n    // \t\t// The object was deleted\n    // \t\tthis.log.debug(`object ${id} deleted`);\n    // \t}\n    // }\n\n    /**\n     * private function used to fill the alldevices array\n     * @private\n     */\n    private async refreshDeviceList(): Promise<any> {\n        interface GetObjectViewItem {\n            /** The ID of this object */\n            id: string;\n            /** A copy of the object from the DB */\n            value: ioBroker.Object | null;\n        }\n\n        return await this.getObjectViewAsync('digitalstrom-vdc', 'listDevicesFullObj', {\n            startkey: 'digitalstrom-vdc.' + this.instance + '.',\n            endkey: 'digitalstrom-vdc.' + this.instance + '.\\u9999',\n        }).then((doc: { rows: GetObjectViewItem[] }) => {\n            if (doc && doc.rows) {\n                const deviceObjects: any = { backEnd: [], frondEnd: [] };\n                for (let i = 0; i < doc.rows.length; i++) {\n                    const id = doc.rows[i].id;\n                    const obj: any = doc.rows[i].value;\n                    if (obj && Object.keys(obj).length > 0) {\n                        if (\n                            obj.deviceObj &&\n                            typeof obj.deviceObj == 'object' &&\n                            Object.keys(obj.deviceObj).length > 0\n                        ) {\n                            // TODO check old code: if (obj.deviceObj.dsConfig) {\n                            this.log.debug('Found ' + id + ': ' + JSON.stringify(obj.deviceObj));\n                            this.log.debug('Found ' + id + ': ' + JSON.stringify(obj));\n                            deviceObjects.backEnd.push(obj.deviceObj.native.deviceObj);\n                            deviceObjects.frondEnd.push(obj.deviceObj);\n                        }\n                    }\n                }\n                if (!doc.rows.length) console.log('No objects found.');\n                this.log.debug('add deviceObjects: ' + JSON.stringify(deviceObjects.backEnd));\n                return deviceObjects;\n            } else {\n                console.log('No objects found: ');\n                return [];\n            }\n        });\n    }\n\n    // If you need to react to object changes, uncomment the following block and the corresponding line in the constructor.\n    // You also need to subscribe to the objects with `this.subscribeObjects`, similar to `this.subscribeStates`.\n    // /**\n    //  * Is called if a subscribed object changes\n    //  */\n    private onObjectChange(id: string, obj: ioBroker.Object | null | undefined): void {\n        if (obj) {\n            // The object was changed\n            this.log.debug(`object ${id} changed: ${JSON.stringify(obj)}`);\n        } else {\n            // The object was deleted\n            this.log.debug(`object ${id} deleted`);\n        }\n    }\n\n    // TODO: This function is not used, should be checked, if not, required delete Greeting issi\n    private async replyMultiSensor(affectedDevice: any): Promise<void> {\n        const elements: Array<any> = [];\n        for (const [key, value] of Object.entries(affectedDevice.watchStateID)) {\n            const subState = await this.getForeignStateAsync(value as string);\n            if (subState) {\n                elements.push({\n                    name: key as string,\n                    elements: [\n                        { name: 'age', value: { vDouble: 10 } },\n                        { name: 'error', value: { vUint64: '0' } },\n                        { name: 'value', value: { vDouble: subState.val } },\n                    ],\n                });\n            }\n        }\n        this.vdc.sendUpdate(affectedDevice.dsConfig.dSUID, [\n            {\n                name: 'sensorStates',\n                elements: elements,\n            },\n        ]);\n    }\n\n    /**\n     * Is called if a subscribed state changes\n     */\n    private onStateChange(id: string, state: ioBroker.State | null | undefined): void {\n        if (state) {\n            // The state was changed\n            //this.log.debug(`state ${id} changed: ${state.val} (ack = ${state.ack})`);\n\n            // inform vdc\n            const affectedDevice = this.allDevices.backEnd.find(\n                (d: any) => d.watchStateID == id || Object.values(d.watchStateID).indexOf(id) > -1,\n            );\n            if (affectedDevice && typeof affectedDevice.watchStateID == 'object') {\n                const updateName = Object.keys(affectedDevice.watchStateID).find(\n                    (key) => affectedDevice.watchStateID[key] === id,\n                );\n                if (affectedDevice.deviceType == 'multiSensor') {\n                    // this.replyMultiSensor(affectedDevice);\n                    if (\n                        affectedDevice.modifiers &&\n                        typeof affectedDevice.modifiers == 'object' &&\n                        updateName &&\n                        affectedDevice.modifiers[updateName]\n                    ) {\n                        state.val = (state.val as number) * parseFloat(affectedDevice.modifiers[updateName]);\n                    }\n                    this.vdc.sendUpdate(affectedDevice.dsConfig.dSUID, [\n                        {\n                            name: 'sensorStates',\n                            elements: [\n                                {\n                                    name: updateName,\n                                    elements: [\n                                        { name: 'age', value: null },\n                                        { name: 'error', value: { vUint64: '0' } },\n                                        { name: 'value', value: { vDouble: state.val } },\n                                    ],\n                                },\n                            ],\n                        },\n                    ]);\n                } else if (affectedDevice.deviceType == 'sensor') {\n                    if (\n                        affectedDevice.modifiers &&\n                        typeof affectedDevice.modifiers == 'object' &&\n                        updateName &&\n                        affectedDevice.modifiers[updateName]\n                    ) {\n                        state.val = (state.val as number) * parseFloat(affectedDevice.modifiers[updateName]);\n                    }\n                    this.vdc.sendUpdate(affectedDevice.dsConfig.dSUID, [\n                        {\n                            name: 'sensorStates',\n                            elements: [\n                                {\n                                    name: updateName,\n                                    elements: [\n                                        { name: 'age', value: { vDouble: 0.1 } },\n                                        { name: 'error', value: { vUint64: '0' } },\n                                        { name: 'value', value: { vDouble: state.val } },\n                                    ],\n                                },\n                            ],\n                        },\n                    ]);\n                } else if (affectedDevice.deviceType == 'presenceSensor') {\n                    const newState = state.val ? 1 : 0;\n                    this.vdc.sendUpdate(affectedDevice.dsConfig.dSUID, [\n                        {\n                            name: 'binaryInputStates',\n                            elements: [\n                                {\n                                    name: updateName,\n                                    elements: [\n                                        { name: 'age', value: { vDouble: 1 } },\n                                        { name: 'error', value: { vUint64: '0' } },\n                                        { name: 'value', value: { vBool: newState } },\n                                    ],\n                                },\n                            ],\n                        },\n                    ]);\n                } else if (affectedDevice.deviceType == 'binarySensor') {\n                    const newState = state.val ? 1 : 0;\n                    this.vdc.sendUpdate(affectedDevice.dsConfig.dSUID, [\n                        {\n                            name: 'binaryInputStates',\n                            elements: [\n                                {\n                                    name: updateName,\n                                    elements: [\n                                        { name: 'age', value: { vDouble: 1 } },\n                                        { name: 'error', value: { vUint64: '0' } },\n                                        { name: 'value', value: { vBool: newState } },\n                                    ],\n                                },\n                            ],\n                        },\n                    ]);\n                } else if (affectedDevice.deviceType == 'smokeAlarm') {\n                    const newState = state.val ? 1 : 0;\n                    this.vdc.sendUpdate(affectedDevice.dsConfig.dSUID, [\n                        {\n                            name: 'binaryInputStates',\n                            elements: [\n                                {\n                                    name: updateName,\n                                    elements: [\n                                        { name: 'age', value: { vDouble: 1 } },\n                                        { name: 'error', value: { vUint64: '0' } },\n                                        { name: 'value', value: { vBool: newState } },\n                                    ],\n                                },\n                            ],\n                        },\n                    ]);\n                } else if (affectedDevice.deviceType == 'button') {\n                    let newState = 0;\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                    // @ts-ignore\n                    if (state && state.val >= 0 && state.val <= 14) newState = state.val;\n\n                    this.vdc.sendUpdate(affectedDevice.dsConfig.dSUID, [\n                        {\n                            name: 'buttonInputStates',\n                            elements: [\n                                {\n                                    name: updateName,\n                                    elements: [\n                                        { name: 'age', value: { vDouble: 1 } },\n                                        { name: 'clickType', value: { vUint64: newState } },\n                                        { name: 'error', value: { vUint64: '0' } },\n                                        { name: 'value', value: { vBool: 0 } },\n                                    ],\n                                },\n                            ],\n                        },\n                    ]);\n                } else if (affectedDevice.deviceType == 'awayButton') {\n                    // const newState = state.val ? 1 : 0;\n                    this.vdc.sendUpdate(affectedDevice.dsConfig.dSUID, [\n                        {\n                            name: 'buttonInputStates',\n                            elements: [\n                                {\n                                    name: updateName,\n                                    elements: [\n                                        { name: 'age', value: { vDouble: 1 } },\n                                        { name: 'clickType', value: { vUint64: 4 } },\n                                        { name: 'error', value: { vUint64: '0' } },\n                                        { name: 'value', value: { vBool: 0 } },\n                                    ],\n                                },\n                            ],\n                        },\n                    ]);\n                    setTimeout(() => {\n                        this.vdc.sendUpdate(affectedDevice.dsConfig.dSUID, [\n                            {\n                                name: 'buttonInputStates',\n                                elements: [\n                                    {\n                                        name: updateName,\n                                        elements: [\n                                            { name: 'age', value: { vDouble: 1 } },\n                                            { name: 'clickType', value: { vUint64: 6 } },\n                                            { name: 'error', value: { vUint64: '0' } },\n                                            { name: 'value', value: { vBool: 0 } },\n                                        ],\n                                    },\n                                ],\n                            },\n                        ]);\n                    }, 3.5 * 1000);\n                } else if (affectedDevice.deviceType == 'doorbell') {\n                    // const newState = state.val ? 1 : 0;\n                    if (state.val) {\n                        // send event only if val is true\n                        this.vdc.sendUpdate(affectedDevice.dsConfig.dSUID, [\n                            {\n                                name: 'buttonInputStates',\n                                elements: [\n                                    {\n                                        name: updateName,\n                                        elements: [\n                                            { name: 'age', value: { vDouble: 1 } },\n                                            { name: 'clickType', value: { vUint64: 0 } },\n                                            { name: 'error', value: { vUint64: '0' } },\n                                            { name: 'value', value: { vBool: 0 } },\n                                        ],\n                                    },\n                                ],\n                            },\n                        ]);\n                    }\n                }\n            }\n        } else {\n            // The state was deleted\n            this.log.debug(`state ${id} deleted`);\n        }\n    }\n\n    // If you need to accept messages in your adapter, uncomment the following block and the corresponding line in the constructor.\n    // /**\n    //  * Some message was sent to this instance over message box. Used by email, pushover, text2speech, ...\n    //  * Using this method requires \"common.messagebox\" property to be set to true in io-package.json\n    //  */\n    private async onMessage(obj: ioBroker.Message): Promise<void> {\n        const respond = (response: any): void => {\n            if (obj.callback) this.sendTo(obj.from, obj.command, response, obj.callback);\n        };\n        // some predefined responses, so we only have to define them once\n        const responses = {\n            ACK: { error: null },\n            OK: { error: null, result: 'ok' },\n            ERROR_UNKNOWN_COMMAND: { error: 'Unknown command!' },\n            MISSING_PARAMETER: (paramName: string) => {\n                return { error: 'missing parameter \"' + paramName + '\"!' };\n            },\n            COMMAND_ACTIVE: { error: 'command already active' },\n            RESULT: (result: unknown) => ({ error: null, result }),\n            ERROR: (error: string) => ({ error }),\n        };\n        this.log.debug(`received onMessage ${JSON.stringify(obj)}`);\n        if (typeof obj === 'object') {\n            switch (obj.command) {\n                case 'addNewDevice': {\n                    this.log.debug('Add devices command received ' + JSON.stringify(obj));\n                    try {\n                        const deviceObj = obj.message as any;\n                        this.log.debug(JSON.stringify(deviceObj));\n                        await this.setObjectNotExistsAsync(`DS-Devices.configuredDevices.${deviceObj.id}`, {\n                            type: 'state',\n                            common: {\n                                name: deviceObj.name,\n                                type: 'boolean',\n                                role: 'indicator',\n                                read: true,\n                                write: true,\n                            },\n                            native: {\n                                deviceObj,\n                            },\n                        });\n                        await this.setStateAsync(`DS-Devices.configuredDevices.${deviceObj.id}`, true);\n                        this.allDevices = await this.refreshDeviceList();\n                        return respond(responses.OK);\n                        //\n                    } catch (err: any) {\n                        console.error('Error while parsing object', err);\n                        return respond(responses.ERROR(err));\n                    }\n                }\n                case 'VanishDevice': {\n                    this.log.debug(`sendVanishDevice command receveid for device ${obj.message}`);\n                    break;\n                }\n                case 'ListDevices': {\n                    this.allDevices = await this.refreshDeviceList();\n                    this.log.debug(`sendToListDevices - ${JSON.stringify(this.allDevices.frondEnd)}`);\n                    return respond(responses.RESULT(this.allDevices.frondEnd));\n                }\n                case 'RemoveDevice': {\n                    this.log.debug(`Remove device for ${JSON.stringify(obj.message)} received`);\n                    const deviceObj = obj.message as any;\n                    this.log.debug(`removing ${deviceObj._id}`);\n                    await this.delObject(deviceObj._id as string);\n                    this.log.debug(`Device ${JSON.stringify(obj.message)} successfully removed`);\n                    // if (deviceObj.dSUID) this.vdc.sendVanish(deviceObj.dSUID as string);\n                    this.allDevices = await this.refreshDeviceList();\n                    return respond(responses.OK);\n                }\n                case 'getHostIp': {\n                    this.log.debug(`getHostIp command received`);\n                    const hostObj = await this.getForeignObjectAsync(`system.host.${this.host}`);\n                    const ipv4 = hostObj?.common.address.filter((ip: string) => ip.includes('.'));\n                    return respond(responses.RESULT(ipv4));\n                }\n            }\n\n            /* TODO check old stuff from other brancch!\n\n\t\t\t            if (obj.command === \"send\") {\n                // e.g. send email or pushover or whatever\n                this.log.debug(\"send command\");\n\n                // Send response in callback if required\n                if (obj.callback) this.sendTo(obj.from, obj.command, \"Message received\", obj.callback);\n            }\n            if (obj.command === \"genSDUID\") {\n                this.log.debug(\"genSDUID command receveid\");\n                if (obj.callback) this.sendTo(obj.from, obj.command, \"Message received\", obj.callback);\n            }\n\n            if (obj.command === \"getRunning\") {\n                // this.log.debug(\"getRunning command received\");\n                this.getState(\"DS-Devices.VDC.running\", (error, state) => {\n                    //this.log.debug(JSON.stringify(state));\n                    // this.log.debug(JSON.stringify(obj));\n                    if (obj.callback) this.sendTo(obj.from, obj.command, { state }, obj.callback);\n                });\n            }\n\n            if (obj.command === \"sendVanishDevice\") {\n                this.log.debug(`sendVanishDevice command receveid for device ${obj.message}`);\n            }\n\n            if (obj.command === \"sendListDevices\") {\n                this.log.debug(`sendListDevices command receveid`);\n                /* this.getStates(\"DS-Devices.configuredDevices.*\", (error, devices) => {\n                    this.log.debug(`the following devices are configured on the system ${JSON.stringify(devices)}`);\n                    if (obj.callback) this.sendTo(obj.from, obj.command, { devices }, obj.callback);\n                }); */\n            /*\n\t\t\tif (obj.callback) this.sendTo(obj.from, obj.command, this.allDevices, obj.callback);\n\t\t}\n\n\t\tif (obj.command === \"sendRemoveDevice\") {\n\t\t\tthis.log.debug(`Remove device for ${JSON.stringify(obj.message)} received`);\n\t\t\tconst deviceObj = obj.message as any;\n\t\t\tthis.delObject(`DS-Devices.configuredDevices.${deviceObj.id as string}`, async (error: any) => {\n\t\t\t\tthis.log.debug(`Device ${JSON.stringify(obj.message)} successfully with message ${error} removed`);\n\t\t\t\tthis.log.debug(JSON.stringify(deviceObj));\n\t\t\t\tif (obj.callback) this.sendTo(obj.from, obj.command, {}, obj.callback);\n\n\t\t\t\tif (deviceObj.dSUID) this.vdc.sendVanish(deviceObj.dSUID as string);\n\t\t\t\tthis.allDevices = await this.refreshDeviceList();\n\t\t\t});\n\t\t}\n\n\t\tif (obj.command === \"sendAddDevice\") {\n\t\t\tthis.log.debug(\"Add devices command received \" + JSON.stringify(obj));\n\t\t\ttry {\n\t\t\t\tconst deviceObj = obj.message as any;\n\t\t\t\tthis.log.debug(JSON.stringify(deviceObj));\n\t\t\t\tthis.setObjectNotExistsAsync(`DS-Devices.configuredDevices.${deviceObj.id}`, {\n\t\t\t\t\ttype: \"state\",\n\t\t\t\t\tcommon: {\n\t\t\t\t\t\tname: deviceObj.name,\n\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\trole: \"indicator\",\n\t\t\t\t\t\tread: true,\n\t\t\t\t\t\twrite: true,\n\t\t\t\t\t},\n\t\t\t\t\tnative: {\n\t\t\t\t\t\tdeviceObj,\n\t\t\t\t\t},\n\t\t\t\t}).then(async (success) => {\n\t\t\t\t\tthis.log.debug(`Device created ${success}`);\n\t\t\t\t\tawait this.setStateAsync(`DS-Devices.configuredDevices.${deviceObj.id}`, true);\n\t\t\t\t\tif (obj.callback) this.sendTo(obj.from, obj.command, { deviceObj }, obj.callback);\n\t\t\t\t\tthis.allDevices = await this.refreshDeviceList();\n\t\t\t\t});\n\t\t\t} catch (err) {\n\t\t\t\tconsole.error(\"Error while parsing object\", err);\n\t\t\t}\n\t\t}\n\t\t\t */\n        }\n    }\n}\n\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new DigitalstromVdc(options);\n} else {\n    // otherwise start the instance directly\n    (() => new DigitalstromVdc())();\n}\n"],
  "mappings": "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",
  "names": []
}
